/**
 * Audio Enhancements Module
 *
 * Professional audio quality improvements:
 * - Anti-aliasing for oscillators (PolyBLEP)
 * - DC blocking filter
 * - Soft clipping/limiting
 * - Improved interpolation
 * - Voice spreading/unison effects
 *
 * A Paul Phillips Manifestation
 */

import 'dart:math' as math;
import 'dart:typed_data';

/// PolyBLEP anti-aliasing for oscillators
/// Reduces aliasing artifacts in square and sawtooth waves
class PolyBLEP {
  /// Calculate PolyBLEP correction value
  static double polyBlep(double phase, double phaseIncrement) {
    // Normalize phase to 0-1 range
    if (phase < phaseIncrement) {
      // Rising edge
      final t = phase / phaseIncrement;
      return t + t - t * t - 1.0;
    } else if (phase > 1.0 - phaseIncrement) {
      // Falling edge
      final t = (phase - 1.0) / phaseIncrement;
      return t * t + t + t + 1.0;
    }
    return 0.0;
  }

  /// Anti-aliased sawtooth wave
  static double sawtoothAA(double phase, double phaseIncrement) {
    // Raw sawtooth
    double sample = 2.0 * phase - 1.0;
    // Apply PolyBLEP correction
    sample -= polyBlep(phase, phaseIncrement);
    return sample;
  }

  /// Anti-aliased square wave
  static double squareAA(double phase, double phaseIncrement) {
    // Raw square wave
    double sample = phase < 0.5 ? 1.0 : -1.0;
    // Apply PolyBLEP correction at both edges
    sample += polyBlep(phase, phaseIncrement);
    sample -= polyBlep((phase + 0.5) % 1.0, phaseIncrement);
    return sample;
  }

  /// Anti-aliased triangle wave (derived from integrated square)
  static double triangleAA(double phase, double phaseIncrement) {
    // Triangle can be generated by integrating square wave
    // Using polynomial approximation for efficiency
    double sample;
    if (phase < 0.25) {
      sample = 4.0 * phase;
    } else if (phase < 0.75) {
      sample = 2.0 - 4.0 * phase;
    } else {
      sample = 4.0 * phase - 4.0;
    }
    return sample;
  }
}

/// DC blocking filter (high-pass filter at ~10Hz)
/// Removes DC offset that can cause clicking and reduce headroom
class DCBlocker {
  double _x1 = 0.0;
  double _y1 = 0.0;
  final double _coefficient;

  DCBlocker({double sampleRate = 44100.0})
      : _coefficient = 1.0 - (2.0 * math.pi * 10.0 / sampleRate);

  /// Process sample through DC blocker
  double process(double input) {
    final output = input - _x1 + _coefficient * _y1;
    _x1 = input;
    _y1 = output;
    return output;
  }

  /// Reset filter state
  void reset() {
    _x1 = 0.0;
    _y1 = 0.0;
  }
}

/// Soft clipper/limiter with smooth saturation curve
/// Prevents harsh digital clipping while maintaining loudness
class SoftClipper {
  final double threshold;
  final double ratio;

  SoftClipper({
    this.threshold = 0.8,
    this.ratio = 0.5,
  });

  /// Apply soft clipping to sample
  double process(double input) {
    final absInput = input.abs();

    if (absInput <= threshold) {
      return input;
    }

    // Smooth saturation curve using tanh-like function
    final excess = absInput - threshold;
    final compressed = threshold + excess * ratio / (1.0 + excess * ratio);

    // Preserve sign
    return input.sign * compressed;
  }

  /// Process entire buffer
  Float32List processBuffer(Float32List buffer) {
    final result = Float32List(buffer.length);
    for (int i = 0; i < buffer.length; i++) {
      result[i] = process(buffer[i]);
    }
    return result;
  }
}

/// Linear interpolation for smoother parameter changes
class Interpolator {
  double _current;
  double _target;
  final double _smoothing; // 0-1, higher = slower

  Interpolator({
    double initial = 0.0,
    double smoothing = 0.95,
  })  : _current = initial,
        _target = initial,
        _smoothing = smoothing.clamp(0.0, 0.999);

  /// Set new target value
  void setTarget(double value) {
    _target = value;
  }

  /// Get next interpolated value
  double process() {
    _current = _current * _smoothing + _target * (1.0 - _smoothing);
    return _current;
  }

  /// Jump to value immediately (no interpolation)
  void jump(double value) {
    _current = value;
    _target = value;
  }

  /// Get current value
  double get value => _current;

  /// Check if close to target (within 0.1%)
  bool get isStable => (_current - _target).abs() < 0.001;
}

/// Voice spreading for unison/detune effects
/// Calculates slight pitch offsets for voice spreading
class VoiceSpreader {
  /// Calculate detune amount for voice in unison stack
  /// voiceIndex: 0 to voiceCount-1
  /// spread: 0-1, controls how much spreading
  /// Returns detune in cents
  static double getDetune(int voiceIndex, int voiceCount, double spread) {
    if (voiceCount <= 1) return 0.0;

    // Distribute voices symmetrically around center
    final normalizedIndex = (voiceIndex - (voiceCount - 1) / 2.0) / voiceCount;

    // Use golden ratio for more pleasant spread intervals
    const goldenRatio = 1.618033988749895;
    final offset = normalizedIndex * goldenRatio;

    // Scale by spread amount (max Â±25 cents)
    return offset * spread * 25.0;
  }

  /// Calculate stereo pan position for voice spreading
  /// Returns -1.0 (left) to 1.0 (right)
  static double getPan(int voiceIndex, int voiceCount) {
    if (voiceCount <= 1) return 0.0;

    // Distribute voices across stereo field
    return (voiceIndex / (voiceCount - 1)) * 2.0 - 1.0;
  }
}

/// One-pole lowpass filter (smoothing filter)
class OnePoleFilter {
  double _output = 0.0;
  double _coefficient;

  OnePoleFilter({double frequency = 1000.0, double sampleRate = 44100.0})
      : _coefficient = math.exp(-2.0 * math.pi * frequency / sampleRate);

  /// Process sample
  double process(double input) {
    _output = input + _coefficient * (_output - input);
    return _output;
  }

  /// Set cutoff frequency
  void setFrequency(double frequency, double sampleRate) {
    _coefficient = math.exp(-2.0 * math.pi * frequency / sampleRate);
  }

  /// Reset filter state
  void reset() {
    _output = 0.0;
  }
}

/// Slew rate limiter - prevents parameter changes that are too fast
/// Useful for preventing clicks and zippering noise
class SlewLimiter {
  double _current;
  final double _maxRiseRate;
  final double _maxFallRate;
  final double _sampleRate;

  SlewLimiter({
    double initial = 0.0,
    double maxRisePerSecond = 1000.0,
    double maxFallPerSecond = 1000.0,
    required double sampleRate,
  })  : _current = initial,
        _maxRiseRate = maxRisePerSecond / sampleRate,
        _maxFallRate = maxFallPerSecond / sampleRate,
        _sampleRate = sampleRate;

  /// Process input with slew limiting
  double process(double input) {
    final delta = input - _current;

    if (delta > _maxRiseRate) {
      _current += _maxRiseRate;
    } else if (delta < -_maxFallRate) {
      _current -= _maxFallRate;
    } else {
      _current = input;
    }

    return _current;
  }

  /// Jump to value immediately
  void jump(double value) {
    _current = value;
  }
}

/// Stereo width control
class StereoWidth {
  /// Process stereo pair with width control
  /// width: 0 = mono, 1 = normal stereo, 2 = extra wide
  static (double, double) process(double left, double right, double width) {
    // Mid-side processing
    final mid = (left + right) * 0.5;
    final side = (left - right) * 0.5;

    // Scale side signal by width
    final scaledSide = side * width;

    // Reconstruct stereo
    final newLeft = mid + scaledSide;
    final newRight = mid - scaledSide;

    return (newLeft, newRight);
  }
}

/// Simple delay line for chorus, flanger, etc.
class DelayLine {
  final List<double> _buffer;
  int _writePos = 0;
  final int _maxDelay;

  DelayLine({required int maxDelaySamples})
      : _maxDelay = maxDelaySamples,
        _buffer = List<double>.filled(maxDelaySamples, 0.0);

  /// Write sample to delay line
  void write(double sample) {
    _buffer[_writePos] = sample;
    _writePos = (_writePos + 1) % _maxDelay;
  }

  /// Read sample from delay line with interpolation
  double read(double delaySamples) {
    final delayInt = delaySamples.floor();
    final delayFrac = delaySamples - delayInt;

    final readPos1 = (_writePos - delayInt - 1) % _maxDelay;
    final readPos2 = (_writePos - delayInt - 2) % _maxDelay;

    final sample1 = _buffer[readPos1 < 0 ? readPos1 + _maxDelay : readPos1];
    final sample2 = _buffer[readPos2 < 0 ? readPos2 + _maxDelay : readPos2];

    // Linear interpolation
    return sample1 * (1.0 - delayFrac) + sample2 * delayFrac;
  }

  /// Clear delay line
  void clear() {
    for (int i = 0; i < _maxDelay; i++) {
      _buffer[i] = 0.0;
    }
    _writePos = 0;
  }
}

/// RMS level detector for dynamics processing
class RMSDetector {
  double _rms = 0.0;
  final double _attack;
  final double _release;

  RMSDetector({
    double attackTime = 0.01,
    double releaseTime = 0.1,
    double sampleRate = 44100.0,
  })  : _attack = math.exp(-1.0 / (attackTime * sampleRate)),
        _release = math.exp(-1.0 / (releaseTime * sampleRate));

  /// Process sample and return RMS level
  double process(double input) {
    final square = input * input;
    final coefficient = square > _rms ? _attack : _release;
    _rms = square + coefficient * (_rms - square);
    return math.sqrt(_rms);
  }

  /// Get current RMS level
  double get level => math.sqrt(_rms);

  /// Reset detector
  void reset() {
    _rms = 0.0;
  }
}
